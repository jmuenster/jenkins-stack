{

  "AWSTemplateFormatVersion": "2010-09-09",

  "Description": "multi-az jenkins template",

  "Parameters": {

    "DomainName": {
      "Type": "String"
    },
    "ImageId": {
      "Type": "AWS::EC2::Image::Id"
    },
    "InstanceType": {
      "Type": "String"
    },
    "KeyName": {
      "Type": "AWS::EC2::KeyPair::KeyName"
    },
    "ReqCert": {
      "Type": "String",
      "AllowedValues": [ "Yes", "No" ]
    },
    "VpcFirstOctet": {
      "Type": "String",
      "Default": "10"
    },
    "VpcSecondOctet": {
      "Type": "String",
      "Default": "10"
    },
    "VpcThirdOctet": {
      "Type": "String",
      "Default": "10"
    }

  },

  "Conditions": {

    "ReqCert": { "Fn::Equals": [ { "Ref": "ReqCert" }, "Yes" ] }

  },

  "Resources": {

    "NetworkStack": {
      "Type": "AWS::CloudFormation::Stack",
       "Properties": {
         "Parameters": {
           "FirstOctet": { "Ref": "VpcFirstOctet" },
           "SecondOctet": { "Ref": "VpcSecondOctet" },
           "ThirdOctet": { "Ref": "VpcThirdOctet" }
         },
         "TemplateURL": "https://s3-us-west-2.amazonaws.com/jmuenster-public-templates/vpc-stack/template.json",
         "TimeoutInMinutes": "60"
      }
    },

    "LambdaRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [ {
            "Effect": "Allow",
            "Principal": { "Service": [ "lambda.amazonaws.com" ] },
            "Action": [ "sts:AssumeRole" ]
          } ]
        },
        "Path": "/",
        "Policies": [
          {
            "PolicyName": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" }, "-policy" ] ] },
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                { "Effect": "Allow", "Action": "acm:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "logs:*", "Resource": "*" }
              ]
            }
          }
        ]
      }
    },

    "AsgRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [ {
            "Effect": "Allow",
            "Principal": { "Service": [ "ec2.amazonaws.com" ] },
            "Action": [ "sts:AssumeRole" ]
          } ]
        },
        "Path": "/",
        "Policies": [ 
          {
            "PolicyName": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" }, "-policy" ] ] },
            "PolicyDocument": { 
              "Version": "2012-10-17", 
              "Statement": [
                { "Effect": "Allow", "Action": "cloudformation:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "ec2:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "dynamodb:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "iam:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "kinesis:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "kms:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "lambda:*", "Resource": "*" },
                { "Effect": "Allow", "Action": "s3:*", "Resource": "*" }
              ]
            }
          } 
        ]
      }
    },

    "IamInstanceProfile": {
      "Type": "AWS::IAM::InstanceProfile",
      "Properties": {
        "Path": "/",
        "Roles": [ { "Ref": "AsgRole" } ]
      }
    },

    "Ec2Sg": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" }, "-ec2-sg" ] ] },
        "VpcId": { "Fn::GetAtt" : [ "NetworkStack", "Outputs.VpcId" ] }
      }
    },

    "Ec2SgIngress": {
      "Type": "AWS::EC2::SecurityGroupIngress",
      "Properties": {
        "GroupId": { "Ref": "Ec2Sg" },
        "IpProtocol": "tcp",
        "FromPort": "0",
        "ToPort": "65535",
        "SourceSecurityGroupId": { "Ref": "Ec2Sg" }
      }
    },

    "ElbSg": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" }, "-elb-sg" ] ] },
        "SecurityGroupIngress": [
          {
            "IpProtocol": "tcp",
            "FromPort": "22",
            "ToPort": "22",
            "CidrIp": "0.0.0.0/0"
          },
          {
            "IpProtocol": "tcp",
            "FromPort": "80",
            "ToPort": "80",
            "CidrIp": "0.0.0.0/0"
          },
          {
            "IpProtocol": "tcp",
            "FromPort": "443",
            "ToPort": "443",
            "CidrIp": "0.0.0.0/0"
          }
        ],
        "VpcId": { "Fn::GetAtt" : [ "NetworkStack", "Outputs.VpcId" ] }
      }
    },

    "CreateCertFunction": {
      "Type": "AWS::Lambda::Function",
      "Condition": "ReqCert",
      "Properties": {
      "Code": {
        "ZipFile":  { "Fn::Join": ["\n", [
        "import boto3",
        "import hashlib",
        "import logging",
        "import time",
        "import cfnresponse",
        "log = logging.getLogger()",
        "log.setLevel(logging.DEBUG)",
        "from botocore.exceptions import ClientError",
        "acm = boto3.client( 'acm' )",
        "def wait_for_validation( domain, context ):",
        "  while context.get_remaining_time_in_millis() > 10000:",
        "    time.sleep(5)",
        "    response = acm.list_certificates( CertificateStatuses=[ 'ISSUED' ] )",
        "    if any( cert['DomainName'] == domain for cert in response[ 'CertificateSummaryList' ] ):",
        "        return",
        "    log.info( 'waiting for cert validation' )",
        "  log.warning( 'timed out waiting for cert validation' )",
        "def handler( event, context ):",
        "  responseData = {}",
        "  if event[ 'RequestType' ] == 'Create': ",
        "    domain_name = event[ 'ResourceProperties' ][ 'DomainName' ]",
        "    id_token = hashlib.md5('cfn-{StackId}-{LogicalResourceId}'.format(**event)).hexdigest()",
        "    kwargs = { 'DomainName': domain_name, 'IdempotencyToken': id_token[:30] }",
        "    response = acm.request_certificate(**kwargs)",
        "    responseData[ 'Data' ] = response['CertificateArn']",
        "    wait_for_validation( domain_name, context )",
        "    cfnresponse.send( event, context, cfnresponse.SUCCESS, responseData, response['CertificateArn'] )",
        "  elif event[ 'RequestType' ] == 'Delete': ",
        "    try:",
        "      response = acm.delete_certificate( CertificateArn=event[ 'PhysicalResourceId' ] )",
        "    except:",
        "      log.exception( 'Failure deleting cert' )",
        "      cfnresponse.send( event, context, cfnresponse.FAILED, responseData, event[ 'PhysicalResourceId' ] )",
        "    cfnresponse.send( event, context, cfnresponse.SUCCESS, responseData, event[ 'PhysicalResourceId' ] )",
        "  elif event[ 'RequestType' ] == 'Update': ",
        "    cfnresponse.send( event, context, cfnresponse.SUCCESS, responseData, event[ 'PhysicalResourceId' ] )"
        ]]}
      },
      "Handler": "index.handler",
      "Runtime": "python2.7",
      "Timeout": "300",
      "Role": { "Fn::GetAtt": [ "LambdaRole", "Arn" ] }
      }
    },

    "Cert": {
      "Type": "Custom::Cert",
      "Condition": "ReqCert",
      "Properties": {
        "DomainName": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" } ] ] },
        "ServiceToken": { "Fn::GetAtt": [ "CreateCertFunction", "Arn" ] }
      }
    },

    "Elb": {
      "Type": "AWS::ElasticLoadBalancing::LoadBalancer",
      "Properties": {
        "ConnectionSettings": { "IdleTimeout": "3600" },
        "HealthCheck": {
          "Target": "TCP:22",
          "HealthyThreshold": "2",
          "UnhealthyThreshold": "10",
          "Interval": "20",
          "Timeout": "10"
        },
        "Listeners": [ 
          { "LoadBalancerPort": "22", "InstancePort": "22", "Protocol": "TCP" },
          { 
            "LoadBalancerPort": { "Fn::If": [ "ReqCert", "443", "80" ] }, 
            "InstancePort": "8080", 
            "Protocol": { "Fn::If": [ "ReqCert", "HTTPS", "HTTP" ] },
            "SSLCertificateId": { "Fn::If": [ "ReqCert", { "Ref": "Cert" }, { "Ref": "AWS::NoValue" } ] }
          }
        ],
        "Scheme": "internet-facing",
        "SecurityGroups": [ { "Ref": "ElbSg" }, { "Ref": "Ec2Sg" } ],
        "Subnets": [ 
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PublicSubnetAId" ] }, 
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PublicSubnetBId" ] }, 
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PublicSubnetCId" ] }
        ]
      }
    },

    "ARecord": {
      "Type": "AWS::Route53::RecordSet",
      "Properties": {
        "HostedZoneName": { "Fn::Join": [ "", [ { "Ref": "DomainName" }, "." ] ] },
        "Comment": "a record",
        "Name": { "Fn::Join": [ "", [ { "Ref": "AWS::StackName" }, ".", { "Ref": "DomainName" }, "." ] ] },
        "Type": "A",
        "AliasTarget": {
          "HostedZoneId": { "Fn::GetAtt": ["Elb", "CanonicalHostedZoneNameID"] },
          "DNSName": { "Fn::GetAtt": ["Elb","DNSName"] }
        }
      }
    },

    "LC": {
      "Type": "AWS::AutoScaling::LaunchConfiguration",
      "Properties": {
        "BlockDeviceMappings": [ { "DeviceName": "/dev/sda1", "Ebs": { "VolumeSize": "40" } } ],
        "IamInstanceProfile": { "Ref": "IamInstanceProfile" },
        "ImageId": { "Ref": "ImageId" },
        "InstanceType": { "Ref": "InstanceType" },
        "KeyName": { "Ref": "KeyName" },
        "SecurityGroups": [ { "Ref": "Ec2Sg" } ],
        "UserData": {
          "Fn::Base64": {
            "Fn::Join": [ "", [
              "#!/bin/bash -xe \n",
              "yum-config-manager --enable epel \n",
              "yum install -y ansible git pwgen zip nfs-utils \n",
              "yum -y update \n",
              "[ -f /root/.ssh/id_rsa ] || ssh-keygen -t rsa -N '' -f /root/.ssh/id_rsa \n",
              "cat /root/.ssh/id_rsa.pub >> /root/.ssh/authorized_keys \n",
              "cd /opt && git clone https://github.com/jmuenster/jenkins-stack.git \n",
              "echo \"$( curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone ).", { "Ref": "Efs" }, ".efs.", { "Ref": "AWS::Region" }, 
                ".amazonaws.com:/ /efs nfs4 nfsvers=4.1 0 0" >> /etc/fstab \n",
              "mount /efs \n",
              "[ -f /efs/.admin_pass ] || touch /efs/.admin_pass && chmod 400 /efs/.admin_pass && pwgen 12 1 > /efs/.admin_pass \n",
              "#cd jenkins-stack/ansible \n",
              "#ansible-galaxy install geerlingguy.jenkins -p ./roles/ \n",
              "#ansible-playbook -v -c local config.yml --extra-vars \"admin_password=$( cat /root/.admin_pass )\" \n",
              "#/opt/aws/bin/cfn-signal --stack ", { "Ref": "AWS::StackName" }, " --resource Asg --region ", { "Ref": "AWS::Region" }, " -s true \n"
            ] ]
          }
        }
      }
    },

    "Asg": {
      "Type": "AWS::AutoScaling::AutoScalingGroup",
      "Properties": {
        "DesiredCapacity": "1",
        "LaunchConfigurationName": { "Ref": "LC" },
        "LoadBalancerNames": [ { "Ref": "Elb" } ],
        "MinSize": "1",
        "MaxSize": "1",
        "VPCZoneIdentifier": [
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetAId" ] },
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetBId" ] },
          { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetCId" ] }
        ]
      },
      "DependsOn": [ "MountTarget1", "MountTarget2", "MountTarget3" ]
    },

    "Efs": {
      "Type": "AWS::EFS::FileSystem",
      "Properties": {
        "FileSystemTags": [
          {
            "Key": "Name",
            "Value": "TestFileSystem"
          }
        ]
      }
    },

    "MountTarget1": {
      "Type": "AWS::EFS::MountTarget",
      "Properties": {
        "FileSystemId": { "Ref": "Efs" },
        "SubnetId": { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetAId" ] },
        "SecurityGroups": [ { "Ref": "Ec2Sg" } ]        
      }
    },

    "MountTarget2": {
      "Type": "AWS::EFS::MountTarget",
      "Properties": {
        "FileSystemId": { "Ref": "Efs" },
        "SubnetId": { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetBId" ] },
        "SecurityGroups": [ { "Ref": "Ec2Sg" } ]        
      }
    },

    "MountTarget3": {
      "Type": "AWS::EFS::MountTarget",
      "Properties": {
        "FileSystemId": { "Ref": "Efs" },
        "SubnetId": { "Fn::GetAtt" : [ "NetworkStack", "Outputs.PrivateSubnetCId" ] },
        "SecurityGroups": [ { "Ref": "Ec2Sg" } ]        
      }
    }

  },

  "Outputs": {

    "Ssh": {
      "Description": "ssh",
      "Value": { "Fn::Join": [ "", [ "ssh -i ~/.ssh/", { "Ref": "KeyName" }, ".pem ec2-user@", { "Ref": "ARecord" } ] ] }
    },
    "Url": {
      "Description": "url",
      "Value": { "Fn::Join": [ "", [ { "Fn::If": [ "ReqCert", "https://", "http://" ] }, { "Ref": "ARecord" } ] ] }
    }

  }

}
